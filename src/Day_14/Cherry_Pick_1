class Solution {
    public int help(int r1 ,int c1 , int r2  , int[][] grid,int[][][] dp){
        int c2 = r1 + c1 - r2;
        int n = grid.length , m = grid[0].length;
        if(r1 >= n || r2 >= n || c1 >= m || c2 >= m || grid[r1][c1] == -1 ||
        grid[r2][c2] == -1)return Integer.MIN_VALUE/2;

        if(r1 == n-1 && c1 == m-1)return grid[r1][c1];

        if(dp[r1][c1][r2] != -1)return dp[r1][c1][r2];

        int cherries = 0;
        if(r1 == r2 && c1 == c2){
            cherries += grid[r1][c1];
        }else cherries += grid[r1][c1]+ grid[r2][c2];

        int f1 = help(r1 , c1+1 , r2 , grid , dp);//hh
        int f2 = help(r1 + 1 , c1 , r2 , grid ,dp);//v,h
        int f3 = help(r1 + 1 , c1 , r2+1 , grid ,dp);//v,v
        int f4 = help(r1 ,c1 + 1 , r2 +1 , grid ,dp);//h,v

        cherries += Math.max(Math.max(f1 , f2) , Math.max(f3 , f4));
        return dp[r1][c1][r2]= cherries;
    }
    public int cherryPickup(int[][] grid) {
        int n = grid.length;
        int[][][] dp = new int[n][n][n];
        for(int i = 0;i < n;i++){
            for(int j = 0;j < grid[0].length;j++){
                Arrays.fill(dp[i][j] , -1);
            }
        }
       return Math.max(0, help(0 , 0  , 0 , grid , dp));
    }
}